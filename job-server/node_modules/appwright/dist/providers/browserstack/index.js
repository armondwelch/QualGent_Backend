"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserStackDeviceProvider = void 0;
const async_retry_1 = __importDefault(require("async-retry"));
const form_data_1 = __importDefault(require("form-data"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const device_1 = require("../../device");
const API_BASE_URL = "https://api-cloud.browserstack.com/app-automate";
const envVarKeyForBuild = (projectName) => `BROWSERSTACK_APP_URL_${projectName.toUpperCase()}`;
function getAuthHeader() {
    const userName = process.env.BROWSERSTACK_USERNAME;
    const accessKey = process.env.BROWSERSTACK_ACCESS_KEY;
    const key = Buffer.from(`${userName}:${accessKey}`).toString("base64");
    return `Basic ${key}`;
}
class BrowserStackDeviceProvider {
    sessionDetails;
    sessionId;
    project;
    constructor(project) {
        this.project = project;
    }
    async globalSetup() {
        if (!(process.env.BROWSERSTACK_USERNAME && process.env.BROWSERSTACK_ACCESS_KEY)) {
            throw new Error("BROWSERSTACK_USERNAME and BROWSERSTACK_ACCESS_KEY are required environment variables for this device provider.");
        }
        const buildPath = this.project.use.buildPath;
        console.log(`Uploading: ${buildPath}`);
        const isUrl = buildPath.startsWith("http");
        let body;
        let headers = {
            Authorization: getAuthHeader(),
        };
        if (isUrl) {
            body = new URLSearchParams({
                url: buildPath,
            });
        }
        else {
            if (!fs_1.default.existsSync(buildPath)) {
                throw new Error(`Build file not found: ${buildPath}`);
            }
            const form = new form_data_1.default();
            form.append("file", fs_1.default.createReadStream(buildPath));
            headers = { ...headers, ...form.getHeaders() };
            body = form;
        }
        const fetch = (await import("node-fetch")).default;
        const response = await fetch(`${API_BASE_URL}/upload`, {
            method: "POST",
            headers,
            body,
        });
        const data = await response.json();
        console.log("Upload response:", data);
        const appUrl = data.app_url;
        process.env[envVarKeyForBuild(this.project.name)] = appUrl;
    }
    async getDevice() {
        const config = this.createConfig();
        return await this.createDriver(config);
    }
    async createDriver(config) {
        const WebDriver = (await import("webdriver")).default;
        const webDriverClient = await WebDriver.newSession(config);
        this.sessionId = webDriverClient.sessionId;
        const bundleId = await this.getAppBundleId();
        const testOptions = {
            expectTimeout: this.project.use.expectTimeout,
        };
        return new device_1.Device(webDriverClient, bundleId, testOptions);
    }
    async getSessionDetails() {
        const response = await fetch(`${API_BASE_URL}/sessions/${this.sessionId}.json`, {
            method: "GET",
            headers: {
                Authorization: getAuthHeader(),
            },
        });
        if (!response.ok) {
            throw new Error(`Error fetching session details: ${response.statusText}`);
        }
        const data = await response.json();
        this.sessionDetails = data.automation_session;
    }
    async getAppBundleId() {
        await this.getSessionDetails();
        return this.sessionDetails?.app_details.app_name ?? "";
    }
    async downloadVideo(outputDir, fileName) {
        await this.getSessionDetails();
        const videoURL = this.sessionDetails?.video_url;
        const pathToTestVideo = path_1.default.join(outputDir, "videos-store", `${fileName}.mp4`);
        const dir = path_1.default.dirname(pathToTestVideo);
        fs_1.default.mkdirSync(dir, { recursive: true });
        console.log(`Video URL: ${videoURL}`);
        /**
         * The BrowserStack video URL initially returns a 200 status,
         * but the video file may still be empty. To avoid downloading
         * an incomplete file, we introduce a delay of 10_000 ms before attempting the download.
         * After the wait, BrowserStack may return a 403 error if the video is not
         * yet available. We handle this by retrying the download until we either
         * receive a 200 response (indicating the video is ready) or reach a maximum
         * of 10 retries, whichever comes first.
         */
        await new Promise((resolve) => setTimeout(resolve, 10_000));
        const fileStream = fs_1.default.createWriteStream(pathToTestVideo);
        if (videoURL) {
            await (0, async_retry_1.default)(async () => {
                const response = await fetch(videoURL, {
                    method: "GET",
                });
                if (response.status !== 200) {
                    // Retry if not 200
                    throw new Error(`Video not found: ${response.status} (URL: ${this.sessionDetails?.video_url})`);
                }
                const reader = response.body?.getReader();
                if (!reader) {
                    throw new Error("Failed to get reader from response body.");
                }
                const streamToFile = async () => {
                    // eslint-disable-next-line no-constant-condition
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done)
                            break;
                        fileStream.write(value);
                    }
                };
                await streamToFile();
                fileStream.close();
            }, {
                retries: 10,
                factor: 2,
                minTimeout: 3_000,
            });
            return new Promise((resolve, reject) => {
                // Ensure file stream is closed even in case of an error
                fileStream.on("finish", () => {
                    console.log(`Download finished and file closed: ${pathToTestVideo}`);
                    resolve({ path: pathToTestVideo, contentType: "video/mp4" });
                });
                fileStream.on("error", (err) => {
                    console.error(`Failed to write file: ${err.message}`);
                    reject(err);
                });
            });
        }
        else {
            return null;
        }
    }
    async syncTestDetails(details) {
        const response = await fetch(`${API_BASE_URL}/sessions/${this.sessionId}.json`, {
            method: "PUT",
            headers: {
                Authorization: getAuthHeader(),
                "Content-Type": "application/json",
            },
            body: details.name
                ? JSON.stringify({
                    name: details.name,
                })
                : JSON.stringify({
                    status: details.status,
                    reason: details.reason,
                }),
        });
        if (!response.ok) {
            throw new Error(`Error setting session details: ${response.statusText}`);
        }
        const responseData = await response.json();
        return responseData;
    }
    createConfig() {
        const platformName = this.project.use.platform;
        const projectName = path_1.default.basename(process.cwd());
        const envVarKey = envVarKeyForBuild(this.project.name);
        if (!process.env[envVarKey]) {
            throw new Error(`process.env.${envVarKey} is not set. Did the file upload work?`);
        }
        return {
            port: 443,
            path: "/wd/hub",
            protocol: "https",
            logLevel: "warn",
            user: process.env.BROWSERSTACK_USERNAME,
            key: process.env.BROWSERSTACK_ACCESS_KEY,
            hostname: "hub.browserstack.com",
            capabilities: {
                "bstack:options": {
                    debug: true,
                    interactiveDebugging: true,
                    networkLogs: true,
                    appiumVersion: "2.6.0",
                    enableCameraImageInjection: true,
                    deviceName: this.project.use.deviceName,
                    osVersion: this.project.use.osVersion,
                    platformName: platformName,
                    buildName: `${projectName} ${platformName}`,
                    sessionName: `${projectName} ${platformName} test`,
                    buildIdentifier: process.env.GITHUB_ACTIONS === "true"
                        ? `CI ${process.env.GITHUB_RUN_ID}`
                        : process.env.USER,
                },
                "appium:autoGrantPermissions": true,
                "appium:app": process.env[envVarKey],
                "appium:autoAcceptAlerts": true,
                "appium:fullReset": true,
            },
        };
    }
}
exports.BrowserStackDeviceProvider = BrowserStackDeviceProvider;
